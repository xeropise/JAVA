## 2장 - 객체 생성과 파괴

    - 객체를 만들어야 할 때와 만들지 않아야 할 때를 구분하는 방법
    - 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법
    - 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령

을 알아볼 예정


***

#### 아이템 1 - 생성자 대신 정적 팩토리 메서드를 고려하라

- 정적 팩토리 메서드가 생성자보다 좋은 장점 다섯 가지  

        1. 이름을 가질 수 있다.
        2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
        4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

- 정적 팩토리 메서드가 생성자보다 나쁜 단점 두 가지

        1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.  
        2. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다
        
***

###### 1. 이름을 가질 수 있다.

    - 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못하나  
      정적 팩토리 메서드는 이름만 잘 지으면 반환된 객체의 특성을 쉽게 묘사 할 수 있다.
      
    - BigInterger(int, int, Random) , BigInteger.probablePrime 중 '어느 쪽이 값이 소수인 BigInteger를 반환한다' 
      라는 의미를 더 잘 설명할지는 자명하다

###### 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
    
   
    - 플라이웨이트 패턴과 비슷한 기법이라 할 수 있다.
    
    - 반복되는 요청에 같은 객체를 반환하는 식으로 어느 인스터를 살아 있게 할지를 철저히 통제할 수 있다.  
      인스턴스 통제(instance-controller) 클래스, 인스턴스를 통제하면 싱글턴(singleton), 인스턴스화 불가로 만들수도 있다.
      
    - 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다.  
    
   [플라이웨이트 패턴(Flyweight pattern)이란? ](https://readystory.tistory.com/137) 
   
###### 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

    - 리턴 타입을 interface 로 하고, 실제 리턴하는 클래스는 이를 구현할 클래스로 반환하는 것으로, 클래스의 상세를 숨기면서  
      유연함을 제공받을 수 있다.
      
    - API를 사용 하는사람이 인터페이스를 사용하도록 유도하고, 구현 클래스들을 숨기게되므로 API 명세가 짧아져 이해하기 쉽다.
      (ex) java.utilCollections)
      
###### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    
    - 클라이언트는 팩토리가 전달하는 객체가 어느 클래스의 인스턴스인지 알 수도 없고, 알 필요도 없다.
    
    - 가령 EnumSet 클래스는 원소의 수에따라 원소가 64개 이하면 RegularEnumSet 인스턴스를 아니라면 JumboEnumSet 인스턴스를 반환한다.
    
###### 5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

     - 인터페이스로 다루기 때문에, 장점이라는 그런 내용.. 책을 참조하는게 낫겠다.. 이해도 안된지만
     
***


###### 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.  

    - 다만, 상속보다 컴포지션을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 받아들일 수도 있다.
     
###### 2. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다

    - 정적 팩토리 메서드는 프로그래머가 찾기 어렵다. 메서드 명을 이름을 잘 지어 문제를 완화해야 한다.
    
***

### 아이템 2 - 생성자에 매개변수가 많다면 빌더를 고려하라.

   - 정적 팩토리 메서드는 생성자와 똑같은 제약이 있는데, 선택적 매개변수가 많을 때에는 적절히 대응하기 어렵다.
   
   - [점층적 생성자 패턴](https://ifcontinue.tistory.com/6)이 주로 사용된다. 이로 인해 매개변수 개수가 많아지면  
     클라이언트가 코드를 작성하거나 읽기 어렵다.
     
   - 대안인 [자바 빈즈 패턴](https://effortguy.tistory.com/14)이 있으나, 이 패턴은 객체 하나를 만들려면 메서드를  
     여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다. 일관성이 무너지는 문제  
     때문에 클래스를 불변으로 만들 수 없으며 스레드 안전성을 얻으려면 추가적인 작업을 해줘야만 한다.
     
   - 최종적인 대안으로는 [빌더 패턴](https://conatuseus.tistory.com/42)이 있다. 클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수만 생성자를 호출해  
     빌더 객체를 얻는다, 그런 다음에 제공하는 setter 메서드를 호출해 원하는 선택 매개 변수들을 설정할 수 있다.  
     (메서드 체이닝 이용)
       
   - 최종적인 결론은 생성자나 정적 팩토리 메서드가 처리해야 할 매개변수가 많다면, 빌더 패턴을 선택하는게 더 낫다.
     
***

### 아이템 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라

   - [싱글턴](https://medium.com/webeveloper/%EC%8B%B1%EA%B8%80%ED%84%B4-%ED%8C%A8%ED%84%B4-singleton-pattern-db75ed29c36) 이란 인스턴스를 오직 하나만 생성할 수 있는  
     클래스를 말한다. 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워 질 수 있다.  
     > 타입을 인터페이스로 정의한 다음, 그 인터페이스를 구현해서 만든 싱글턴이 아니라면, 싱글턴 인스턴스를 가짜(mock) 구현으로 대체할 수 없기 때문
     
   - 싱글턴을 만드는 방식은 보통 2가지 이다.  
     두 방식 모두 생성자는 private으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다
   
###### 1. 첫번째인 public static 멤버가 final 필드인 방식이다.
   
   ```Java
   public class Elvis {
        public static final Elvis INSTANCE = new Elvis();
        private Elvis() { ... }
        
        public void leaveTheBuilding() { ... }
   }
   ```
   > private 생성자는 public static final 필드인 Elvis.INSTANCE를 초기화할 때 한 번만 호출된다. public 이나 protected 생성자가 없으므로 Elvis 클래스가 초기화될 때 만들어진 인스턴스가 전체 시스템에서 하나뿐임이 보장된다.  
     단, 예외는 있음 리플렉션 API인 AccessibleObject.setAccessible 을 사용해 private 생성자를 호출 가능하다.  
     이것을 방어하려면 생성자를 수정하여 두번째 객체가 생성되려 할 때, 예외를 던지게 하면 된다.

###### 2. 두번째로는 정적 팩토리 메서드를 이용해 public static 멤버를 제공한다.
   
   ```Java
   public class Elvis {
        private static final Evis INSTANCE = new Elvis();
        private Elvis() { ... }
        public static Elvis getInstance() { return INSTANCE; }
        
        public void leaveTheBuilding() { ... }
   }
   ```
   * 장점
        - API를 바꾸지 않고도, 싱글턴이 아니게 변경할 수 있다는 점  
        - 원한다면 정적 팩토리를 제네릭 싱글턴 팩토리로 만들 수 있다는 점  
        - 정적 팩토레 메소드 참조를 공급자(supplier)로 사용할 수 있다는 점
        
###### 둘 중 하나의 방식으로 만든 싱글턴 클래스를 직렬화하려면 단순히 Serializable을 구현한다고 선언하는 것만으로 부족하다. 

   - 모든 인스턴스 필드를 일시적(transient)라고 선언하고, readResovle 메서드를 제공해야 한다.  [참조](https://madplay.github.io/post/what-is-readresolve-method-and-writereplace-method)
   
   - 이렇게 하지 않는 경우, 직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 만들어지게 된다.
   

###### 3. 세 번째 방법으로는 원소가 하나인 열거 타입을 선언 하는 방법이 있다.

    ```Java
    public enum Elvis {
        INSTANCE;
        
        public void leaveTheBuilding() { ... }
    }
    ```
    
   - public 필드 방식과 유사하나, 직렬화가 쉬우며, 리플렉션 공격으로 인스턴스가 추가 생성되는 일을 완벽히 맞아 준다.  
   
   - 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.  
   
   - 단, 만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없음.  
    (열거 타입이 다른 인터페이스를 구현하도록 선언할 수는 있음)
   

***



