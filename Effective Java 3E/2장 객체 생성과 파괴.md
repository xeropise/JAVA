## 2장 - 객체 생성과 파괴

    - 객체를 만들어야 할 때와 만들지 않아야 할 때를 구분하는 방법
    - 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법
    - 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령

을 알아볼 예정


***

### 아이템 1 - 생성자 대신 정적 팩토리 메서드를 고려하라

- 정적 팩토리 메서드가 생성자보다 좋은 장점 다섯 가지  

        1. 이름을 가질 수 있다.
        2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
        4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

- 정적 팩토리 메서드가 생성자보다 나쁜 단점 두 가지

        1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.  
        2. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다
    
***

###### 1. 이름을 가질 수 있다.

    - 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못하나  
      정적 팩토리 메서드는 이름만 잘 지으면 반환된 객체의 특성을 쉽게 묘사 할 수 있다.
      
    - BigInterger(int, int, Random) , BigInteger.probablePrime 중 '어느 쪽이 값이 소수인 BigInteger를 반환한다' 
      라는 의미를 더 잘 설명할지는 자명하다

###### 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.


    - 플라이웨이트 패턴과 비슷한 기법이라 할 수 있다.
    
    - 반복되는 요청에 같은 객체를 반환하는 식으로 어느 인스터를 살아 있게 할지를 철저히 통제할 수 있다.  
      인스턴스 통제(instance-controller) 클래스, 인스턴스를 통제하면 싱글턴(singleton), 인스턴스화 불가로 만들수도 있다.
      
    - 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다.  

   [플라이웨이트 패턴(Flyweight pattern)이란? ](https://readystory.tistory.com/137) 

###### 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

    - 리턴 타입을 interface 로 하고, 실제 리턴하는 클래스는 이를 구현할 클래스로 반환하는 것으로, 클래스의 상세를 숨기면서  
      유연함을 제공받을 수 있다.
      
    - API를 사용 하는사람이 인터페이스를 사용하도록 유도하고, 구현 클래스들을 숨기게되므로 API 명세가 짧아져 이해하기 쉽다.
      (ex) java.utilCollections)

###### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

    - 클라이언트는 팩토리가 전달하는 객체가 어느 클래스의 인스턴스인지 알 수도 없고, 알 필요도 없다.
    
    - 가령 EnumSet 클래스는 원소의 수에따라 원소가 64개 이하면 RegularEnumSet 인스턴스를 아니라면 JumboEnumSet 인스턴스를 반환한다.

###### 5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

     - 인터페이스로 다루기 때문에, 장점이라는 그런 내용.. 책을 참조하는게 낫겠다.. 이해도 안된지만

***


###### 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.  

    - 다만, 상속보다 컴포지션을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 받아들일 수도 있다.

###### 2. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다

    - 정적 팩토리 메서드는 프로그래머가 찾기 어렵다. 메서드 명을 이름을 잘 지어 문제를 완화해야 한다.

***

### 아이템 2 - 생성자에 매개변수가 많다면 빌더를 고려하라.

   - 정적 팩토리 메서드는 생성자와 똑같은 제약이 있는데, 선택적 매개변수가 많을 때에는 적절히 대응하기 어렵다.
   
   - [점층적 생성자 패턴](https://ifcontinue.tistory.com/6)이 주로 사용된다. 이로 인해 매개변수 개수가 많아지면  
     클라이언트가 코드를 작성하거나 읽기 어렵다.
     
   - 대안인 [자바 빈즈 패턴](https://effortguy.tistory.com/14)이 있으나, 이 패턴은 객체 하나를 만들려면 메서드를  
     여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다. 일관성이 무너지는 문제  
     때문에 클래스를 불변으로 만들 수 없으며 스레드 안전성을 얻으려면 추가적인 작업을 해줘야만 한다.
     
   - 최종적인 대안으로는 [빌더 패턴](https://conatuseus.tistory.com/42)이 있다. 클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수만 생성자를 호출해  
     빌더 객체를 얻는다, 그런 다음에 제공하는 setter 메서드를 호출해 원하는 선택 매개 변수들을 설정할 수 있다.  
     (메서드 체이닝 이용)
     
   - 최종적인 결론은 생성자나 정적 팩토리 메서드가 처리해야 할 매개변수가 많다면, 빌더 패턴을 선택하는게 더 낫다.
     
***

### 아이템 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라

   - [싱글턴](https://medium.com/webeveloper/%EC%8B%B1%EA%B8%80%ED%84%B4-%ED%8C%A8%ED%84%B4-singleton-pattern-db75ed29c36) 이란 인스턴스를 오직 하나만 생성할 수 있는  
     클래스를 말한다. 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워 질 수 있다.  
     
     > 타입을 인터페이스로 정의한 다음, 그 인터페이스를 구현해서 만든 싱글턴이 아니라면, 싱글턴 인스턴스를 가짜(mock) 구현으로 대체할 수 없기 때문
     
   - 싱글턴을 만드는 방식은 보통 2가지 이다.  
     두 방식 모두 생성자는 private으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다

###### 1. 첫번째인 public static 멤버가 final 필드인 방식이다.

   ```Java
   public class Elvis {
        public static final Elvis INSTANCE = new Elvis();
        private Elvis() { ... }
        
        public void leaveTheBuilding() { ... }
   }
   ```
   > private 생성자는 public static final 필드인 Elvis.INSTANCE를 초기화할 때 한 번만 호출된다. public 이나 protected 생성자가 없으므로 Elvis 클래스가 초기화될 때 만들어진 인스턴스가 전체 시스템에서 하나뿐임이 보장된다.  
     단, 예외는 있음 리플렉션 API인 AccessibleObject.setAccessible 을 사용해 private 생성자를 호출 가능하다.  
     이것을 방어하려면 생성자를 수정하여 두번째 객체가 생성되려 할 때, 예외를 던지게 하면 된다.

###### 2. 두번째로는 정적 팩토리 메서드를 이용해 public static 멤버를 제공한다.

   ```Java
   public class Elvis {
        private static final Evis INSTANCE = new Elvis();
        private Elvis() { ... }
        public static Elvis getInstance() { return INSTANCE; }
        
        public void leaveTheBuilding() { ... }
   }
   ```
   * 장점
        - API를 바꾸지 않고도, 싱글턴이 아니게 변경할 수 있다는 점  
        - 원한다면 정적 팩토리를 제네릭 싱글턴 팩토리로 만들 수 있다는 점  
        - 정적 팩토레 메소드 참조를 공급자(supplier)로 사용할 수 있다는 점
        
###### 둘 중 하나의 방식으로 만든 싱글턴 클래스를 직렬화하려면 단순히 Serializable을 구현한다고 선언하는 것만으로 부족하다. 

   - 모든 인스턴스 필드를 일시적(transient)라고 선언하고, readResovle 메서드를 제공해야 한다.  [참조](https://madplay.github.io/post/what-is-readresolve-method-and-writereplace-method)
   
   - 이렇게 하지 않는 경우, 직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 만들어지게 된다.


###### 3. 세 번째 방법으로는 원소가 하나인 열거 타입을 선언 하는 방법이 있다.

   ```Java
    public enum Elvis {
        INSTANCE;
        
        public void leaveTheBuilding() { ... }
    }
   ```

   - public 필드 방식과 유사하나, 직렬화가 쉬우며, 리플렉션 공격으로 인스턴스가 추가 생성되는 일을 완벽히 맞아 준다.  
   
   - 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.  
   
   - 단, 만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없음.  

    (열거 타입이 다른 인터페이스를 구현하도록 선언할 수는 있음)


***

### 아이템 4- 인스턴스화를 막으려거든 private 생성자를 사용하라.

   - 기본 타입 값이나 배열 관련 메서드들을 모아놓거나 특정 인터페이스를 구현하느 객체를 생성하는 정적 메서드를 모아놓거나  
     final 클래스와 관련된 메서드들을 모아놓을 대도 있다. final 클래스를 상속해서, 하위 클래스에 메서드를 넣는 건 불가능하기 때문  
     
   - 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한계 아니지만, 생성자를 명시하지 않은 경우, 컴파일러가 자동으로   
     기본 생성자를 만들어준다. 의도치 않게 인스턴스화할 수 있게 된 클래스가 종종 발견된다.
     
   - 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다. 사용자가 오히려 상속해서 쓰라는 의미로 오해할 수 있으니 더 문제다.
     **private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.**

   - 이 방식은 상속을 불가능하게 하는 효과도 있다. 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하게 되는데, 이를  
     private으로 선언했으니 하위 클래스가 상위 클래스의 생성자에 접근할 길이 막혀버린다.
     
     
***


### 아이템 5- 자원을 직접 명시하지 말고, 의존 객체 주입을 사용하라
```Java
public clas SpellChecker {
       private static final Lexicon dictionary = ...;
       
       private SpecllChecker()  {} // 객체 생성 방지 
       
       public static boolean isValid(String word)  { ... }
       public static List<String> suggestions (String typo) { ... }
}
```
> 정적 유틸리티를 잘못 사용

```Java
public class SpellChecker {
        private final Lexicon dictionary = ...;
        
        private SpellChecker(...) {}
        public static SpellCheck INSTANCE = new SpellChecker(...);
        
       public static boolean isValid(String word)  { ... }
       public static List<String> suggestions (String typo) { ... }        
}
```
> 싱글턴을 잘못 사용

- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다. 

- 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 **의존 객체 주입** 패턴을 사용

```Java
public class SpellChecker {
     private final Lexicon dicionary;
     
     public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
     }
     
     public boolean isValid(String word) { ... }
     public List<String> suggestions(String typo) { ... }
}
```

- 자바 8의 Supplier<T> 인터페이스가 팩토리 메서드 패턴을 표현한 완벽한 예이다.
  
```Java
ublic class IType {
    private static final int TYPE_Z = 0;
    private static final int TYPE_A = 1;
    private static final int TYPE_B = 2;

    final static Map<Integer, Supplier<? extends ITypeFactory>> map = new HashMap<>();
    static {
	map.put(TYPE_Z, ITypeFactory::new);
        map.put(TYPE_A, A::new);
        map.put(TYPE_B, B::new);
    }
}

class ITypeFactory {}
class A extends ITypeFactory {}
class B extends ITypeFactory {}
```

***


### 아이템 6 - 불필요한 객체 생성을 피하라

 - 똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다.

 - 다음 코드는 하지 말아야 할 극단적인 예이다.

 ```Java
 String s = new String("bikini");
 ```
 > 실행될 때마다 String 인스턴스를 새로 만든다. 생성자에 넘겨진 'bikini' 자체가 이 생성자로 만들어내려는  
   String 과 기능적으로 완전히 똑같다. 

- 개선하면 다음과 같다.

```Java
String s = "bikini";
```
> 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다.  
  가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 몯느 코드가 같은 객체를 재사용함이 보장된다.

- 생성 비용이 아주 비싼 객체도 더러 있는데, 이 객체를 반복해서 필요하다면 캐싱하여 재사용하길 권한다.  
  안타깝게도 자신이 만드는 객체가 비싼 객체인지를 매번 명확히 알 수는 없다.
  
- 성능을 훨씬 더 끌어 올릴 수 있는 예를 보자.

```Java
static boolean isRomannumeral(String s) {
	return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
		+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

- 위의 방식의 문제는 String.matches 는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만,  
  성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다. 이 메서드가 내부에서 만드는 정규표현식용  
  Pattern 인스턴스는, 한 번 쓰고 버러져서 곧바로 가비지 컬렉션 대상이 된다.
  > Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신(finite state machine)을 만들기 때문에  
    인스턴스 생성 비용이 높다.
  
- 필요한 정규표현식을 표현하는 (불변인) Pattern 인스턴스를 클래스 초기화(정적 초기화) 과정에서 직접  
  캐싱해두고, 나중에 메서드가 호출될 때마다 이 인스턴스를 재사용하는 방식으로 개선할 수 있다.
  
```Java
public class RomanNumerals {
	private static final Pattern ROMAN = Pattern.compile(
		"^(?=.)M*(C[MD]|D?C{0,3})"
		+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
	
	static boolean isRomanNumeral(String s) {
		return ROMAN.matches(s).matches();
	}
	
}
```
> 이렇게 개선하는 경우, 빈번히 호출되는 상황에서 성능을 상당히 끌어올릴 수 있다고 한다. 6.5배?


- 개선된 메서드를 클래스가 초기화된 후 이 메서드를 한 번도 호출하지 않는다면, ROMAN 필드는 쓸데없이  
  초기화된 꼴인데, 메서드가 처음 호출될 때 필드를 초기화하는 지연 초기화(lazy initialization)으로,  
   불필요한 초기화를 없앨 수는 있지만 권하지는 않는다. 지연 초기화는 코드를 복잡하게 만드는데,   
   성능은 크게 개선되지 않을 때가 많기 때문이다.
  
- 객체가 불변이라면 재사용해도 안전함이 명백하다, 하지만 훨씬 덜 명확하거나, 심지어 직관에 반대되는  
  상황도 있다. (어댑터와 Map 인터페이스의 keySet 메서드로 이를 설명하는데 솔직히 잘 모르겠다..)
  
- 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.

```Java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
    	sum += i;
	
   return sum;	
}
```
> sum  변수를 long 이 아닌 Long 으로 선언해서 불필요한 Long 인스턴스가 약 2^31 개가 만들어진다.. 

- 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.

- '객체 생성은 비싸니 피해야 한다' 로 오해하면 안된다. 요즘의 JVM에서는 별다른 일을 하지 않는 작은  
   객체를 생성하고 회수하는 일이 크게 부담되지 않는다. 프로그램의 명확성, 간결성, 기능을 위해서 객체를  
   추가로 생성하는 것이라면 일반적으로 좋은 일이다.
   
- 아주 무거운 객체가 아닌 다음에야 단순히 객체 생성을 피하고자 나만의 객체 풀(pool)을 만들지는 말자.  
  일반적으로 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어트린다.  
  요즘 JVM의 가비지 컬렉터는 상당히 최적화되어서 가벼운객체용을 다룰 때 직접 만든 객체 풀보다 훨씬 빠르다.
  

***

### 아이템 7 다 쓴 객체 참조를 해제하라.

- 자바처럼 Garbege Collector 가 있는 언어를 사용하면 __메모리 관리를 할필요 없다?!  이것은 오해!__ 절대 사실이 아님



```java
public calss Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    
    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }
    
    /**
     * 원소를 위한 공간을 적어도 하나 이상 확보한다.
     * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
     */
    private void ensureCapacity() {
        if (elements.length == size)
            elements == Array.copyof(elements, 2 * size + 1);
    }
}
```

> 메모리 누수는 어디서 일어나는가?



- 테스트를 수행해도 거뜬히 통과할 것이므로, 문제가 없어보이나 꼭꼭 숨어 있는 문제가 있다. 바로 __메모리 누수__, 이 스택을 사용하는 프로그램을 오래 실행하면 가비지 컬렉션 활동과 메모리 사용량이 늘어나 결국 성능이 저하될 것이다.



- 메모리 누수는 어디서 일어날까? 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들을 가비지 컬렉터가 회수하지 않는다. 그 객체들을 더 이상 사용하지 않더라도, 스택이 그 객체들의 __다 쓴 참조(obsolete reference)__ 를 여전히 가지고 있기 떄문이다.



> 다 쓴 참조(obsolete reference) 란?
>
> - 다시 쓰지 않을 참조, 앞의 코드에서는  elements 배열의 활성 영역 밖의 참조들이 모두 여기에 해당한다. 활성 영역은 인덱스가 size보다 작은 원소들로 구성된다.



- 해법은 간단하다. 해당 참조를 다 썼을 때, null 처리(참조 해제) 하면 된다. 각 원소의 참조가 더 이상 필요 없어지는 시점은 pop() 을 호출할 때다.

```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    elements[size] = null // 다 쓴 참조 해제
    return result;
}
```



- 그렇다고 객체를 다 쓰자마자 null 처리하려고 분투할 필요는 없다. 필요 이상으로 프로그램을 지저분하게 만들기 때문, __객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.__ 



- null 처리는 언제 해야 할까? Stack 클래스는 왜 메모리 누수에 취약한 걸까? 스택이 자기 메모리를 직접 관리하기 때문. 위 코드의 스택은 (객체 자체가 아니라 객체 참조를 담고 있음) elemnts 배열로 저장소 풀을 만들어 원소들을 관리하는데, 배열의 활성 영역에 속한 원소들이 사용되고 비활성 영역은 쓰이지 않고 있다. __문제는 가비지 컬렉터는 이 사실을 알 길이 없다__. 가비지 컬렉터가 보기에는 비활성 영역에서 참조하는 객체도 똑같이 유효한 객체다. 비활성 영역의 객체가 더 이상 쓸모 없는 건 프로그래머만 아는 사실이므로 비활성 영역이 되는 순간  null 처리해서 해당 객체를 더 이상 쓰지 않을 것임을 알려야 한다.



- __자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다__. 원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 null 처리 해줘야 한다.



- __캐시 역시 메모리 누수를 일으키는 주범이다__. 객체 참조를 캐시에 넣고 나서, 이 사실을 까맣게 잊은 채 그 객체를 다 쓴 뒤로도 한참을 그냥 놔두는 일을 자주 접할 수 있는데, 운좋게 캐시 외부에서 키(key)를 참조하는 동안만(값이 아님) 엔트리가 살아 있는 캐시가 필요한 상황이라면 WeakHashMap 을 사용해 캐시를 만들자. 다 쓴 엔트리는 그 즉시 자동으로 제거될 것이다. 단, WeakHashMap 은 이러한 상황에서만 유용한다는 사실을 기억하자.



- 캐시를 만들 때 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에, 시간이 지날수록 엔트리의 가치(우선순위)를 떨어트리는 방식을 흔히 사용한다. 이런 방식에서는 쓰지 않는 엔트리를 청소해주기 위해 ScheduledThreadPoolExecutor 와 같은 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법이 존재한다.



- __리스너와 콜백도 메모리 누수의 주범이다__. 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 특별한 조치가 이루어지지 않는 한 콜백은 계속 쌓여갈 것이므로, 콜백을 약한 참조(weak reference)로 저자하면 가비지 컬렉터가 즉시 수거해가도록 하는 방법이 존재한다.

```java
WeakReference<Integer> soft = new WeakReference<Interger>(prime);
```

> prime 이 null 이 되면, 해당 객체를 가리키는 참조가 WeakReference 뿐일 경우, 가비지 컬렉팅의 대상이 된다.

